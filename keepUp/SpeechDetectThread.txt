package com.pachira.dc.thread;

import com.pachira.dc.cache.DetectedSpeechStorage;
import com.pachira.dc.detector.FileFlagTaggedFolderBatchDetector;
import com.pachira.dc.detector.FlagFileNameDefine;
import com.pachira.dc.detector.FolderBatchInfo;
import com.pachira.dc.dimension.parser.DimLineCollectEvent;
import com.pachira.dc.dimension.parser.ResumableDimParser;
import com.pachira.dc.processor.*;
import com.pachira.dc.utils.CollectionUtilsExtend;
import com.pachira.define.ProcessStatus;
import com.pachira.psae.common.*;
import com.pachira.psae.structs.ThreadSafeQueue;
import com.pachira.psae.thread.SafeExitRunnableAdaptor;
import com.pachira.shared.configurator.DynaValue;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;

import javax.inject.Inject;
import javax.inject.Named;
import java.io.*;
import java.util.*;

/**
 * 对原始语音数据进行探测，注意这里只探测语音数据，不关联任务数据
 * 该线程的工作目的是用于在执行任务、语音关联测试前，先开始语音识别
 * 避免语音识别工作阻塞
 *
 * @author liuyusong
 * @version 1.0
 * @date 16-3-4
 */
@Named
public class SpeechDetectThread extends SafeExitRunnableAdaptor {
    private Log log = LogFactory.getLog(SpeechDetectThread.class);

    // 存储语音数据源路径
    private File speechSourcePath;

    // 语音数据源路径中存储语音子数据的目录名称
    // 语音探测和识别现成仅对该子目录下的数据进行识别
    private String speechFolderName = "Sub";
    private String speechPathDimName = "FilePath";
    // 语音是否必须存在
    private boolean speechMustExists = true;

    private boolean isStartUp = true;

    // 批次目录探测器
    private FileFlagTaggedFolderBatchDetector fileFlagTaggedFolderBatchDetector;

    // 归档文件目录
    private File archiveFolder;

    // 语音维度解析器
    private ResumableDimParser dimParser;

    //- edit，使用DetectedSpeechStorage储存已探测未识别语音
    private DetectedSpeechStorage detectedSpeechStorage;

    private Map<File, RecognizeBatchInfo> batchRecognizeStateInfoMap = new LinkedHashMap<>();

    private String speechPath;
    private String textPath;
    private String speechMainFolderName;
    private String textMainFolderName;

    // 语音格式映射
    // 系统会根据扩展名，判断语音格式，然后进行识别
    private Map<String, String> formatMap = new HashMap<>();

    @Override
    public void run() {
        try {
            if (isStartUp) {
                isStartUp = false;
                // 启动该线程时，清理归档文件中无效的数据(tmp文件)
                clearArchiveFolder(archiveFolder.getPath());
                // 启动该线程时，清理无效的processed文件
                initDataSource(speechPath + File.separator + speechMainFolderName);
                initDataSource(textPath + File.separator + textMainFolderName);
            }

            fileFlagTaggedFolderBatchDetector.setSourceFolder(new File(speechSourcePath, speechFolderName));
            fileFlagTaggedFolderBatchDetector.setDetectedFlag(FlagFileNameDefine.DETECTED);

            List<FolderBatchInfo> unRecogSpeechFolderList = new ArrayList<>();
            while (!isExit()) {
                // 判断并清理已处理完成的语音目录
                checkFinishedFolder();

                unRecogSpeechFolderList.clear();
                // 检测一遍，有没有还没有开始处理的目录
                fileFlagTaggedFolderBatchDetector.detectNew(unRecogSpeechFolderList, null);

                // 没检测到数据则循环等待下一步操作
                if (unRecogSpeechFolderList.size() == 0) {
                    ThreadUtils.sleep(100);
                    continue;
                }

                // 对没有处理的数据,按日期排个序
                Collections.sort(unRecogSpeechFolderList, new Comparator<FolderBatchInfo>() {
                    @Override
                    public int compare(FolderBatchInfo o1, FolderBatchInfo o2) {
                        return o1.getBatchDate().compareTo(o2.getBatchDate());
                    }
                });

                for (FolderBatchInfo folder : unRecogSpeechFolderList) {
                    // 如果正在处理了就跳过
                    if (batchRecognizeStateInfoMap.containsKey(folder.getFolder())) {
                        continue;
                    }

                    checkFinishedFolder();
                    // 逐个处理每个语音目录

                    // 语音数据处理分为两个阶段
                    // 1、Detect阶段
                    //    该阶段对语音数据进行枚举
                    // 2、识别阶段
                    //    该阶段对语音数据进行识别
                    // 这里需要根据阶段进行处理
                    // 如果是探测阶段，则先进行数据探测
                    if (!folder.hasFlag(FlagFileNameDefine.DETECTED)) {
                        log.info("detected speech folder " + folder.getFolder());
                        // 枚举该语音目录下的所有语音文件
                        // 以便完成语音探测步骤
                        // 为后面执行语音识别打下基础
                        enumSpeech(folder);
                        // 标记已探测
                        folder.createFlag(FlagFileNameDefine.DETECTED);
                    }

                    // 枚举出来的语音列表保存在flag.speech-lst文件中
                    // 这里对他进行一条一条处理，并跟踪记录
                    // 对一个语音数据目录进行语音识别
                    recognizeBatchFolder(folder);
                }
            }
        } catch (Throwable t) {
            log.error("数据处理异常！", t);
        }
    }

    /**
     * 断电重启后清理为处理完的文件夹下processed文件
     *
     * @param path
     */
    public static void initDataSource(String path) {
        File folder = new File(path);
        folder.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                File folder = new File(dir, name);
                if (folder.isDirectory()) {
                    String path1 = folder.getPath();
                    File pro = new File(path1, "flag.processed");
                    File sch = new File(path1, "flag.schedule");
                    if (pro.exists() && sch.exists()) {
                        List<String> list = FileUtils.loadTextInLineFromFile(sch, "utf-8");
                        CollectionUtilsExtend.tirmList(list);
                        for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
                            if (it.next().endsWith("|0")) {
                                pro.delete();
                                break;
                            }
                        }
                    }
                }
                return false;
            }
        });
    }

    /**
     * 清理归档文件夹中未处理完的数据
     *
     * @param path
     */
    private void clearArchiveFolder(String path) {
        new File(path).listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                File file = new File(dir, name);
                if (name.endsWith(".tmp")) {
                    file.delete();
                } else if (file.isDirectory()) {
                    clearArchiveFolder(file.getPath());
                }
                return false;
            }
        });
    }

    /**
     * 枚举这个批次里的语音数据
     *
     * @param folder 批次目录
     */
    private void enumSpeech(final FolderBatchInfo folder) {
        final BufferedWriter[] writer = new BufferedWriter[1];

        try {
            writer[0] = new BufferedWriter(
                    new OutputStreamWriter(new FileOutputStream(new File(folder.getFolder(), "flag.speech-lst"))));

            final int[] speechCount = new int[]{0};

            dimParser.parseFile(folder.getDimFile(), new DimLineCollectEvent() {
                // FilePath维度对应的位置
                private int pathDimIndex = 0;

                @Override
                public boolean collectKeys(String[] keyArray) {
                    for (int i = 0; i < keyArray.length; ++i) {
                        if (speechPathDimName.equals(keyArray[i].trim())) {
                            pathDimIndex = i;
                            break;
                        }
                    }
                    return true;
                }

                @Override
                public boolean collectValues(String[][] valueArray, boolean end) {
                    if (CollectionUtils.isAbsEmpty(valueArray)) {
                        return true;
                    }

                    for (String[] one : valueArray) {
                        if (one.length - 1 < pathDimIndex || StringUtils.isAbsEmpty(one[pathDimIndex])) {
                            log.warn("this row does not contains speech path dim, skip");
                            continue;
                        }

                        String relPath = one[pathDimIndex];
                        String finalPath = new File(folder.getFolder(), relPath).getAbsolutePath();

                        if (speechMustExists && !FileUtils.fileExist(finalPath)) {
                            log.error("speech file not exists: " + relPath);
                            continue;
                        }

                        if (!formatMap.containsKey(FileUtils.extractExtName(relPath).toLowerCase())) {
                            log.warn("unknown speech format of file: " + relPath);
                            continue;
                        }

                        try {
                            writer[0].write(relPath);
                            writer[0].write(System.lineSeparator());

                            speechCount[0]++;
                        } catch (IOException e) {
                            log.fatal("cannot write speech path line to list file", e);
                        }
                    }

                    return true;
                }
            });

            log.info(String.format("%d found in dir %s",
                    speechCount[0], folder.getFolder()));
        } catch (Exception e) {
            log.fatal("cannot write speech list file in folder:" + folder.getFolder());
        } finally {
            if (writer[0] != null) {
                try {
                    writer[0].close();
                } catch (IOException e) {
                    log.fatal("", e);
                }
            }
        }
    }

    private void checkFinishedFolder() {
        Iterator<RecognizeBatchInfo> it = batchRecognizeStateInfoMap.values().iterator();
        while (it.hasNext()) {
            RecognizeBatchInfo batchInfo = it.next();

            if (batchInfo.getDetectStatus() == ProcessStatus.STOPED
                    && batchInfo.getTotalCount().get() == batchInfo.getRecognizedCount().get()) {
                log.info("speech in folder has been recognized: " + batchInfo.getFolder().getFolder());
                batchInfo.getFolder().createFlag(FlagFileNameDefine.RECOGNIZED);
                it.remove();
            }
        }
    }

    /**
     * 对一个目录进行语音识别
     *
     * @param head 没有处理的文件夹
     */
    private void recognizeBatchFolder(final FolderBatchInfo head) {
        final RecognizeBatchInfo batchInfo = new RecognizeBatchInfo();
        batchInfo.setFolder(head);
        batchInfo.setDetectStatus(ProcessStatus.RUNNING);

        log.info("start to recognize speech in " + head.getFolder());

        FileUtils.eachLineFromFile(new File(head.getFolder().getAbsolutePath(), "flag.speech-lst"),
                "UTF-8",
                new StringOperator() {
                    @Override
                    public void one(int i, String speechPath) {
                        if (i < head.getProcPosition()) {
                            // 跳过已处理标记
                            return;
                        }

                        // 更新识别进度
                        head.setProcPosition(i);
                        String extName = FileUtils.extractExtName(speechPath).toLowerCase();
                        if (!formatMap.containsKey(extName)) {
                            log.warn("cannot determine speech format by extension, skip it");
                            return;
                        }

                        RecogRequest request = new RecogRequest();
                        request.setFolder(head);
                        request.setFormat(formatMap.get(extName));
                        request.setPath(new File(head.getFolder(), speechPath));
                        request.setIncreCount(batchInfo.getRecognizedCount());
                        try {
                            detectedSpeechStorage.push(new PriorityRecogRequest(request));
                        } catch (InterruptedException e) {
                            log.error("Fail to push the speech into unprocessedStorage ", e);
                        }

                        batchInfo.getTotalCount().incrementAndGet();
                    }
                }
        );

        // 标记这个语音批次目录已枚举完毕,
        // checkFinishBatch需要根据该标记确定,是否可以标记已处理
        batchInfo.setDetectStatus(ProcessStatus.STOPED);
        // 把这个批次的语音文件目录枚举完了,就加到batchInfoList中去
        // checkFinishedBatch需要检测并标记是否识别完成
        batchRecognizeStateInfoMap.put(batchInfo.getFolder().getFolder(), batchInfo);
    }

    @Value("${DataCenter.DataSource.Speech.Path:DataCenter/Speech}")
    public void setSpeechSourcePath(File speechSourcePath) {
        this.speechSourcePath = speechSourcePath;
    }

    @Inject
    public void setFileFlagTaggedFolderBatchDetector(FileFlagTaggedFolderBatchDetector fileFlagTaggedFolderBatchDetector) {
        this.fileFlagTaggedFolderBatchDetector = fileFlagTaggedFolderBatchDetector;
    }

    @Value("${DataCenter.ArchiveFolder:data/dc}")
    public void setArchiveFolder(File archiveFolder) {
        this.archiveFolder = archiveFolder;
    }

    @Value("${DataCenter.DataSource.Speech.SubFolderName}")
    public void setSpeechFolderName(String speechFolderName) {
        this.speechFolderName = speechFolderName;
    }

    @Value("${DataCenter.Speech.FormatMap}")
    public void setFormatMap(String formatMapString) {
        // 将录音格式配置解析一下
        Map<String, String> kvMap = StringUtils.parseMap(formatMapString, "\\|", ":");

        for (Map.Entry<String, String> formatString : kvMap.entrySet()) {
            String[] extSplit = formatString.getValue().split(",");

            if (!CollectionUtils.isAbsEmpty(extSplit)) {
                for (String ext : extSplit) {
                    formatMap.put(ext.trim().toLowerCase(), formatString.getKey());
                }
            }
        }
    }

    @Value("${DataCenter.DataSource.Text.Path}")
    public void setTextPath(String textPath) {
        this.textPath = textPath;
    }

    @Value("${DataCenter.DataSource.Text.MainFolderName}")
    public void setTextMainFolderName(String textMainFolderName) {
        this.textMainFolderName = textMainFolderName;
    }

    @Value("${DataCenter.DataSource.Speech.Path}")
    public void setSpeechPath(String speechPath) {
        this.speechPath = speechPath;
    }

    @Value("${DataCenter.DataSource.Speech.MainFolderName}")
    public void setSpeechMainFolderName(String speechMainFolderName) {
        this.speechMainFolderName = speechMainFolderName;
    }

    //- edit，使用DetectedSpeechStorage代替原来的Queue
    @Inject
    @Qualifier("detectedSpeechStorage")
    public void setDetectedSpeechStorage(DetectedSpeechStorage detectedSpeechStorage) {
        this.detectedSpeechStorage = detectedSpeechStorage;
    }

    @Inject
    public void setDimParser(ResumableDimParser dimParser) {
        this.dimParser = dimParser;
    }

    @DynaValue("DataCenter.SpeechSource.SpeechPathDimName")
    public void setSpeechPathDimName(String speechPathDimName) {
        this.speechPathDimName = speechPathDimName;
    }

    @DynaValue("DataCenter.SpeechSource.SpeechMustExists")
    public void setSpeechMustExists(boolean speechMustExists) {
        this.speechMustExists = speechMustExists;
    }
}
