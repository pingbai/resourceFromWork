package com.pachira.dc.processor;

import com.pachira.dc.cache.Storage;
import com.pachira.dc.cache.UnprocessedTaskStorage;
import com.pachira.dc.common.BuildInFieldDefine;
import com.pachira.dc.cache.PriorityTaskBatch;
import com.pachira.dc.common.TaskNode;
import com.pachira.dc.detector.*;
import com.pachira.dc.dimension.parser.DimLineCollectEvent;
import com.pachira.dc.dimension.parser.ResumableDimParser;
import com.pachira.dc.utils.CollectionUtilsExtend;
import com.pachira.dc.utils.MapDBUtils;
import com.pachira.psae.common.CollectionUtils;
import com.pachira.psae.common.FileUtils;
import com.pachira.psae.common.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.Scope;

import javax.inject.Inject;
import javax.inject.Named;
import java.io.File;
import java.text.ParseException;
import java.util.*;

/**
 * 处理有Main和Sub目录的数据源
 *
 * @author liuyusong
 * @version 1.0
 * @date 16-2-29
 */
@Named
@Scope(BeanDefinition.SCOPE_PROTOTYPE)
public class MainWithSubFolderBatchProcessor {
    private Log log = LogFactory.getLog(MainWithSubFolderBatchProcessor.class);
    private static final String SUB_MAPDB_NAME = "sub";
    private static final String MAPDB_DIR_NAME = "_index";

    private ResumableDimParser taskDimParser;
    private ResumableDimParser subDimParser;

    private MultiLineCollector taskDimCollector;
    private MultiLineCollector subDimCollector;

    private MapDBUtils mapDBUtils;

    private String taskIdName;
    private String subIdName;
    private String taskSubRelateName;

    private Integer schedulePoint;

    private Storage taskStorage;

    public void processBatch(final MainWithSubFolderBatchInfo head) {
        taskDimCollector.reset();
        subDimCollector.reset();

        taskDimCollector.setMultiLieCollectEvent(new MultiLieCollectEvent() {
            @Override
            public void onCollectBatch(List<Map<String, String>> values) {
                //初始化游标
                schedulePoint = 0;
                //追加当前处理的任务流水号，转存在MapDB
                File taskScheduleFile = new File(head.getMainFolder().getFolder().getPath(), "flag.schedule");
                //获取任务进度,将状态为0的任务节点记录下来，不能删除文件信息，否则，这一过程在断电，则丢失数据
                List<Integer> rowNumLst = null;
                if (taskScheduleFile.exists() && taskScheduleFile.isFile()) {
                    //将行号信息加到map中
                    rowNumLst = getUnProcessedRowNumLst(taskScheduleFile);
                }
                // 排序
                if (!CollectionUtils.isAbsEmpty(rowNumLst)) {
                    Collections.sort(rowNumLst);
                    head.getMainFolder().setProcPosition(schedulePoint);
                }
                // 将任务和语音进行关联
                Iterator<Map<String, String>> it = values.iterator();
                PriorityTaskBatch taskBatch = new PriorityTaskBatch(new ArrayList<TaskNode>());
                taskBatch.setBatchInfo(head);
                for (; it.hasNext(); ) {
                    TaskNode taskNode = new TaskNode();
                    Map<String, String> taskMap = it.next();
                    Integer lineNum = Integer.valueOf(taskMap.get("lineNum"));
                    //先关联断电前未关联的部分
                    boolean isBreakPoint = false;
                    if (!CollectionUtils.isAbsEmpty(rowNumLst)) {
                        if (!rowNumLst.contains(lineNum)) {
                            continue;
                        } else {
                            rowNumLst.remove(lineNum);
                            isBreakPoint = true;
                        }
                    }else{
                        if (lineNum <= schedulePoint){
                            isBreakPoint = true;
                        }
                    }

                    if (!isBreakPoint) {
                        String cursor = lineNum + "|" + taskMap.get(taskIdName) + "|0";
                        FileUtils.appendLineToFile(taskScheduleFile, String.valueOf(cursor));
                    }
                    //移除无用信息
                    taskMap.remove("lineNum");
                    taskNode.getTaskDimMap().putAll(taskMap);
                    taskNode.getTaskDimMap().put(BuildInFieldDefine.DIM_BASE_DIR,
                            head.getMainFolder().getFolder().getAbsolutePath());
                    taskNode.setBatchDate(head.getMainFolder().getBatchDate());

                    if (!combineTaskWithSub(taskNode)) {
                        log.error("cannot combine task and sub, drop it");
                        it.remove();
                        continue;
                    }
                    taskBatch.addTaskNode(taskNode);
                }

                //将任务节点推送到未处理任务队列
                try {
                    taskStorage.push(taskBatch);
                    
                } catch (InterruptedException e) {
                    log.error("Fail to push the taskBatch into unprocessedStorage ", e);
                }
            }
        });

        if (head.getSubFolder() == null) {
            log.fatal("SUB FOLDER is needed for MainWithSubTaskProcessor, please check your config");
        }

        // 涉及到Main和Sub之间的关联，这里需要先将Sub数据解析并建立Map，方便后面读取
        // 由于需要关联的数据量可能很大，不可能全部读取到内存，所以这里使用MapDB存储
        log.info("indexing sub data for combination, dir: " + head.getSubFolder().getFolder());
        if (!importSubToMapDB(head.getSubFolder())) {
            log.error("cannot import sub data to mapdb, exit, dir = "
                    + head.getSubFolder().getFolder());
            return;
        }

        // 然后处理任务数据，将任务数据的语音数据关联后发出
        File dimFile = head.getMainFolder().getDimFile();
        log.info("processing dimension " + dimFile.getPath());
        assert taskDimParser != null;
        try {
            taskDimParser.setLastDetectPosition(head.getMainFolder().getProcPosition());
            taskDimParser.parseFile(dimFile, new DimLineCollectEvent() {
                @Override
                public boolean collectKeys(String[] keyArray) {
                    return taskDimCollector.collectKeys(keyArray);
                }

                @Override
                public boolean collectValues(String[][] valueArray, boolean end) {
                    head.getMainFolder().setProcPosition(taskDimParser.getLastDetectPosition());
                    return taskDimCollector.collectValues(valueArray, end);
                }
            });
        } catch (ParseException e) {
            log.error("cannot parse dimension file + " + dimFile, e);
        }
    }

    /**
     * 得到未处理成功的行号
     * @param taskScheduleFile
     * @return
     */
    private List<Integer> getUnProcessedRowNumLst(File taskScheduleFile){
        List<String> list = FileUtils.loadTextInLineFromFile(taskScheduleFile, "utf-8");
        CollectionUtilsExtend.tirmList(list);
        List<Integer> unProcessedRowNumLst = new ArrayList<>();
        for(Iterator<String> it = list.iterator();it.hasNext();){
            String next = it.next();
            if(StringUtils.isAbsEmpty(next)){
                continue;
            }
            if(next.endsWith("|0")){
                unProcessedRowNumLst.add(Integer.valueOf(next.substring(0, next.indexOf("|"))));
            }
        }
        //获取断电后的游标
        String str = list.get(list.size()-1);
        schedulePoint = Integer.valueOf(str.substring(0,str.indexOf("|")));
        return unProcessedRowNumLst;
    }

    public void addRemoveMark(MainWithSubFolderBatchInfo head) {
        PriorityTaskBatch removeMark = new PriorityTaskBatch(null);
        removeMark.setBatchInfo(head);
        removeMark.couldRemoveSource();
        try {
            taskStorage.push(removeMark);
        } catch (InterruptedException e) {
            log.error("Fail to push the taskBatch into unprocessedStorage ", e);
        }
    }

    /**
     * 将Sub和Main中的数据进行关联
     *
     * @param taskNode 待关联的任务
     * @return 关联成功返回true，否则返回false；只有在Main下的所有Sub全部关联上才算成功
     */
    private boolean combineTaskWithSub(TaskNode taskNode) {
        String subIDList = (String) taskNode.getTaskDimMap().get(taskSubRelateName);
        String taskID = (String) taskNode.getTaskDimMap().get(taskIdName);

        if (StringUtils.isAbsEmpty(subIDList)) {
            // 没有需要关联的数据，则返回true
            log.debug("no sub will be combine for " + taskID);
            return true;
        }

        String[] ids = subIDList.split(",");
        ids = StringUtils.trimStringArray(ids);

        Set<String> subIdList = new HashSet<>();
        for (String id : ids) {
            subIdList.add(id);
        }

        Map<String, String> subMap = new HashMap<>();
        mapDBUtils.pop(SUB_MAPDB_NAME, subIdList, subMap);

        if (subMap.size() != subIdList.size()) {
            log.warn("required sub list is not match real sub list");
        }

        for (Map.Entry<String, String> sub : subMap.entrySet()) {
            Map<String, Object> map = StringUtils.jsonToObject(sub.getValue(), Map.class);
            taskNode.getSubList().add(map);
        }

        return true;
    }

    private boolean importSubToMapDB(final FolderBatchInfo subFolder) {
        if (mapDBUtils != null) {
            mapDBUtils.close();
        }

        mapDBUtils = new MapDBUtils(new File(subFolder.getFolder(), MAPDB_DIR_NAME));

        subDimCollector.setMultiLieCollectEvent(new MultiLieCollectEvent() {
            @Override
            public void onCollectBatch(List<Map<String, String>> values) {
                for (Map<String, String> valueMap : values) {
                    valueMap.put(BuildInFieldDefine.DIM_BASE_DIR,
                            subFolder.getFolder().getAbsolutePath());
                    if (valueMap.get(subIdName) != null) {
                        mapDBUtils.push("sub", valueMap.get(subIdName),
                                StringUtils.objectToJson(valueMap));
                    } else {
                        log.error("cannot find " + subIdName + " from valueMap, please check your dim file!");
                    }
                }
            }
        });

        try {
            subDimParser.parseFile(subFolder.getDimFile(), subDimCollector);
            return true;
        } catch (ParseException e) {
            log.error("cannot parse sub dim file " + subFolder.getDimFile(), e);
            return false;
        }
    }

    public void setTaskStorage(UnprocessedTaskStorage taskStorage) {
        this.taskStorage = taskStorage;
    }

    @Inject
    public void setTaskDimCollector(MultiLineCollector taskDimCollector) {
        this.taskDimCollector = taskDimCollector;
    }

    @Inject
    public void setSubDimCollector(MultiLineCollector subDimCollector) {
        this.subDimCollector = subDimCollector;
    }

    public void setSubIdName(String subIdName) {
        this.subIdName = subIdName;
    }

    public void setTaskIdName(String taskIdName) {
        this.taskIdName = taskIdName;
    }

    public void setTaskSubRelateName(String taskSubRelateName) {
        this.taskSubRelateName = taskSubRelateName;
    }

    public void setTaskDimParser(ResumableDimParser taskDimParser) {
        this.taskDimParser = taskDimParser;
    }

    public void setSubDimParser(ResumableDimParser subDimParser) {
        this.subDimParser = subDimParser;
    }
}
